{"version":3,"sources":["Layout.tsx","Scales.ts","TabProcessor.ts","App.tsx","Parser.ts","index.tsx"],"names":["Box","styled","div","space","layout","background","border","shadow","typography","Flex","flexbox","chromaticScaleSharps","chromaticScaleFlats","chromaticScaleFlatsUpperCase","map","key","toUpperCase","chromaticNoteNames","Array","from","Set","tabLinePattern","RegExp","join","processTabBlock","inputLines","blockLength","chromaticNoteName","keyOffsets","line","keyName","match","trim","indexOf","Error","output","_","prevRead","i","latestRead","index","length","push","slice","parseFretNumberString","latestNotes","fretNumber","convertFretNumberToNote","noteWithTwoChars","some","note","prevReadHadTwoDigitNumber","every","forEach","fretNumberString","parseInt","keyOffset","toLowerCase","GitHubBadgeBox","Background","NoPrintBox","InputTextArea","textarea","OutputTextBox","OutputText","pre","App","useState","inputText","setInputText","outputText","setOutputText","signature","setSignature","useEffect","alphaTab","outArray","split","currentBlock","currentBlockLength","convertToAlphaTab","textChunks","currentChunk","href","loading","width","height","src","className","alt","data-recalc-dims","style","marginBottom","fontSize","p","m","onInput","e","target","value","alignItems","flexDirection","ml","onChange","chunk","isArray","Fragment","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9fc017a6.chunk.js","sourcesContent":["import styled from \"styled-components\";\nimport {\n    background,\n    BackgroundProps,\n    border, BorderProps,\n    flexbox, FlexboxProps,\n    layout,\n    LayoutProps,\n    shadow, ShadowProps,\n    space,\n    SpaceProps, typography, TypographyProps\n} from 'styled-system'\n\nexport interface BoxProps extends SpaceProps, LayoutProps, BackgroundProps, BorderProps, ShadowProps, TypographyProps {\n}\n\nexport const Box = styled.div<BoxProps>`\n  display: block;\n  ${space};\n  ${layout};\n  ${background};\n  ${border};\n  ${shadow};\n  ${typography}\n`\n\nexport interface FlexProps extends SpaceProps, LayoutProps, BackgroundProps, BorderProps, ShadowProps, FlexboxProps, TypographyProps {\n}\n\nexport const Flex = styled.div<FlexProps>`\n  display: flex;\n  ${flexbox};\n  ${space};\n  ${layout};\n  ${background};\n  ${border};\n  ${typography}\n  ${shadow};\n`;","\nexport const chromaticScaleSharps = [\"C\", \"C#\", \"D\" , \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\nexport const chromaticScaleFlats  = [\"C\", \"Db\", \"D\" , \"Eb\", \"E\", \"F\", \"Gb\", \"G\", \"Ab\", \"A\", \"Bb\", \"B\"];\nexport const chromaticScaleFlatsUpperCase  = chromaticScaleFlats.map(key => key.toUpperCase());\n\nconst chromaticNoteNames = Array.from(new Set([...chromaticScaleSharps, ...chromaticScaleFlats]));\n//export const tabLineBeginPattern = new RegExp(`^(${chromaticNoteNames.join(\"|\")}) ?\\\\|`, \"i\");\nexport const tabLinePattern = new RegExp(`^((${chromaticNoteNames.join(\"|\")}) ?\\\\|.+\\\\|)`, \"i\");","import {chromaticScaleFlatsUpperCase, chromaticScaleSharps, tabLinePattern} from \"./Scales\";\n\nconst SEPARATOR = '-';\n\n/**\n * All lines of the input array must be of the same length\n * Every line must match the tabLinePattern RegExp defined in Scales.ts\n * @param inputLines\n * @param blockLength\n * @param chromaticNoteName\n */\nexport function processTabBlock(inputLines: string[], blockLength: number, chromaticNoteName: string[]) {\n    const keyOffsets = inputLines.map(line => {\n        let keyName = line.match(tabLinePattern)![2].toUpperCase().trim();\n        if (chromaticScaleFlatsUpperCase.indexOf(keyName) >= 0) {\n            return chromaticScaleFlatsUpperCase.indexOf(keyName);\n        } else if (chromaticScaleSharps.indexOf(keyName) >= 0) {\n            return chromaticScaleSharps.indexOf(keyName);\n        } else {\n            throw new Error(\"could not find key for \" + keyName);\n        }\n    });\n\n    let output: string[] = inputLines.map(_ => \"\");\n\n    let prevRead: (string | null)[] | null = null;\n    for (let i = 0; i < blockLength; i++) {\n        let latestRead: (string | null)[] | null = [];\n        for (let index = 0; index < inputLines.length; index++) {\n            const line = inputLines[index];\n            if (prevRead && prevRead[index] && prevRead[index]!.length > 1) {\n                //the last time we read from this line there was a two digit number\n                //ignore this line for this iteration\n                latestRead.push(null);\n                continue;\n            }\n            const match = line.slice(i).match(/^\\d+/);\n            if (match) {\n                latestRead.push(parseFretNumberString(match[0]));\n            } else {\n                latestRead.push(null);\n            }\n        }\n\n        let latestNotes = latestRead.map((fretNumber, index) =>\n            fretNumber ? convertFretNumberToNote(fretNumber, keyOffsets[index], chromaticNoteName) : null)\n\n        const noteWithTwoChars = latestNotes.some(note => note && note.length > 1)\n        const prevReadHadTwoDigitNumber = prevRead && prevRead.some(note => note && note.length > 1)\n\n        if (!latestNotes.every(note => note === null) || !prevReadHadTwoDigitNumber) {\n        for (let index = 0; index < latestNotes.length; index++) {\n            const note = latestNotes[index];\n            if (note) {\n                output[index] += note;\n                if (note.length < 2 && noteWithTwoChars) {\n                    output[index] += SEPARATOR;\n                }\n            } else {\n                if (prevRead && prevRead[index] && prevRead[index]!.length > 1) {\n                    //the last time we read from this line there was a two digit number\n                    //ignore the current character and place a seperatore\n                    output[index] += SEPARATOR;\n                } else {\n                    output[index] += inputLines[index].slice(i, i + 1);\n                }\n                if (noteWithTwoChars) {\n                    output[index] += SEPARATOR;\n                }\n            }\n        }\n    }\n        prevRead = latestRead;\n    }\n\n    //add comments and stuff written after the actual tab back to the output\n    inputLines.forEach((line, index) => {\n        if(line.length > blockLength) {\n            output[index] += line.slice(blockLength);\n        }\n    })\n    return output\n}\n\nfunction parseFretNumberString(fretNumberString: string) {\n    if (fretNumberString.length > 2 || parseInt(fretNumberString) > 24) {\n        //in this case we have multiple numbers right behind each other without separator\n        //most guitars no not have more than 24 frets\n        //only process first number\n        return fretNumberString.slice(0, 1)\n    } else {\n        return fretNumberString;\n    }\n}\n\nfunction convertFretNumberToNote(fretNumberString: string, keyOffset: number, chromaticNoteName: string[]) {\n    const fretNumber = parseInt(fretNumberString);\n    const note = chromaticNoteName[(keyOffset + fretNumber) % 12]\n    return fretNumber >= 12 ? note.toLowerCase() : note;\n}","import React, {useEffect, useState} from 'react';\nimport styled from \"styled-components\";\nimport {Box, Flex} from \"./Layout\";\nimport {convertToAlphaTab} from \"./Parser\";\nimport {chromaticScaleFlats, chromaticScaleSharps} from \"./Scales\";\n\nconst GitHubBadgeBox = styled(Box)`\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: 10;\n`;\n\nconst Background = styled(Box)`\n  background-color: #282c34;\n  min-height: 100vh;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  font-size: calc(10px + 2vmin);\n  color: white;\n`;\n\nconst NoPrintBox = styled(Box)`\n  @media print {\n    display: none !important;\n  }\n`;\n\nconst InputTextArea = styled.textarea`\n  width: 100%;\n  height: 30vh;\n  color: black;\n  font-family: monospace;\n  font-size: 13px;\n  white-space: pre;\n  overflow-wrap: normal;\n  overflow-x: scroll;\n`;\n\nconst OutputTextBox = styled(Box)`\n  background-color: white;\n  width: 100%;\n  color: black;\n  font-family: monospace;\n  font-size: 13px;\n  padding: 3px;\n  overflow: auto;\n  @media print {\n    div {\n      break-inside: avoid;\n      page-break-inside: avoid;\n    }\n  }\n`;\n\nconst OutputText = styled.pre`\n  padding: 0;\n  margin: 0;\n`;\n\nconst demoInput = \"This is a utility for converting regular tab to AlphaTab, a format suggested by StudyBass.\\n\" +\n    \"See https://www.studybass.com/lessons/reading-music/alpha-tab/ for more information.\\n\" +\n    \"Just paste you tab right in here :)\\n\" +\n    \"\\n\" +\n    \"Formatting: Every line which should be interpreted as tablature should start with the root note of the string, \\n\" +\n    \"then a pipe (|), then the actual tablature and at the end another pipe.\\n\" +\n    \"\\n\" +\n    \"Demo:\\n\" +\n    \"G|---------------------------------------------|\\n\" +\n    \"D|------------------5----------------------17--|\\n\" +\n    \"A|--------2----5--------------14----17---------|\\n\" +\n    \"E|---3-------------------15--------------------|\\n\" +\n    \"\\n\" +\n    \"Demo in Drop D:\\n\" +\n    \"F|---------------------------------------------|\\n\" +\n    \"C|------------------5----------------------17--|\\n\" +\n    \"G|--------2----5--------------14----17---------|\\n\" +\n    \"D|---3-------------------15--------------------|\";\n\nfunction App() {\n    const [inputText, setInputText] = useState<string>(demoInput);\n    const [outputText, setOutputText] = useState<(string | string[])[]>([]);\n    const [signature, setSignature] = useState(\"flats\");\n\n    useEffect(() => {\n        setInputText(inputText);\n        const alphaTab = convertToAlphaTab(inputText,\n            signature === \"flats\" ? chromaticScaleFlats : chromaticScaleSharps);\n\n        //group lines with are non empty together for better printability (no page breaks in tab)\n        const textChunks: (string | string[])[] = [];\n        let currentChunk = [];\n        for (let i = 0; i < alphaTab.length; i++) {\n            if (alphaTab[i].length > 0) {\n                currentChunk.push(alphaTab[i]);\n            } else {\n                if (currentChunk.length > 0) {\n                    textChunks.push(currentChunk);\n                    currentChunk = [];\n                }\n                textChunks.push(alphaTab[i]);\n            }\n        }\n        if (currentChunk.length > 0) {\n            textChunks.push(currentChunk);\n        }\n        setOutputText(textChunks);\n    }, [inputText, signature])\n\n    return (\n        <Box>\n            <GitHubBadgeBox>\n                <a href=\"https://github.com/jannst/alpha-tab-converter\">\n                    <img loading=\"lazy\" width=\"149\" height=\"149\"\n                         src=\"https://github.blog/wp-content/uploads/2008/12/forkme_right_green_007200.png?resize=149%2C149\"\n                         className=\"attachment-full size-full\" alt=\"Fork me on GitHub\"\n                         data-recalc-dims=\"1\"/>\n                </a>\n            </GitHubBadgeBox>\n            <Background>\n                <h4 style={{marginBottom: \"0px\"}}>Alpha Tab Converter</h4>\n                <Box fontSize={10} p={0} m={0}>\n                    Made By Jannik Sturhann\n                </Box>\n                <Box width=\"80%\">\n                    <NoPrintBox>\n                        <p>Input</p>\n                        <InputTextArea\n                            onInput={e => setInputText((e.target as HTMLTextAreaElement).value || \"\")}\n                            value={inputText}\n                        />\n                    </NoPrintBox>\n                    <Box>\n                        <NoPrintBox>\n                            <Flex alignItems=\"center\">\n                                <p>Output</p>\n                                <Flex flexDirection=\"column\" fontSize={20} ml=\"30px\">\n                                    <span>Key Signature Sign</span>\n                                    <select value={signature} onChange={e => setSignature(e.target.value)}>\n                                        <option value=\"flats\">Flats (b)</option>\n                                        <option value=\"sharps\">Sharps (#)</option>\n                                    </select>\n                                </Flex>\n                            </Flex>\n                        </NoPrintBox>\n                        <OutputTextBox>\n                            {outputText.map((chunk, index) => {\n                                if (Array.isArray(chunk)) {\n                                    return (<Box><OutputText key={index}>\n                                        {chunk.join(\"\\n\")}\n                                    </OutputText></Box>);\n                                } else {\n                                    return (<React.Fragment key={index}>\n                                        {chunk}<br/>\n                                    </React.Fragment>);\n                                }\n                            })}\n                        </OutputTextBox>\n                    </Box>\n                </Box>\n            </Background>\n        </Box>\n    );\n}\n\nexport default App;\n","import {tabLinePattern} from \"./Scales\";\nimport {processTabBlock} from \"./TabProcessor\";\n\nexport function convertToAlphaTab(inputText: string, chromaticNoteName: string[]) {\n    let outArray: string[] = [];\n    const inputLines = inputText.split('\\n').map(line => line.trim());\n\n    //find text lines which describe 'tab' and group them together\n    let currentBlock: string[] = [];\n    let currentBlockLength = 0;\n    for (let i = 0; i < inputLines.length; i++) {\n        const match = inputLines[i].match(tabLinePattern);\n        if (match) {\n            if (currentBlock.length) {\n                if (match[0].length === currentBlockLength) {\n                    //append a line to the current block\n                    currentBlock.push(inputLines[i]);\n                } else {\n                    //the line does not match the length of the current block.\n                    //process the current block and create a new one\n                    outArray.push(...processTabBlock(currentBlock, currentBlockLength, chromaticNoteName));\n                    currentBlock= [inputLines[i]];\n                    currentBlockLength = match[0].length;\n                }\n            } else {\n                currentBlock= [inputLines[i]];\n                currentBlockLength = match[0].length;\n            }\n        } else {\n            if(currentBlock.length) {\n                //the current line does not match the regexp for tab lines but there is an active block\n                //process the block and then append the text line\n                outArray.push(...processTabBlock(currentBlock, currentBlockLength, chromaticNoteName));\n                currentBlock = [];\n                currentBlockLength = 0;\n            }\n            outArray.push(inputLines[i])\n        }\n    }\n\n    //if there is and active block after loop finish add it to the output\n    if(currentBlock.length) {\n        outArray.push(...processTabBlock(currentBlock, currentBlockLength, chromaticNoteName));\n    }\n    return outArray;\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}