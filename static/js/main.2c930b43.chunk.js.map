{"version":3,"sources":["Layout.tsx","Scales.ts","TabProcessor.ts","App.tsx","Parser.ts","index.tsx"],"names":["Box","styled","div","space","layout","background","border","shadow","typography","Flex","flexbox","chromaticScaleSharps","chromaticScaleFlats","chromaticScaleFlatsUpperCase","map","key","toUpperCase","chromaticNoteNames","Array","from","Set","tabLinePattern","RegExp","join","processTabBlock","inputLines","blockLength","chromaticNoteName","keyOffsets","line","keyName","match","trim","indexOf","Error","output","_","prevRead","i","latestRead","index","length","push","slice","parseFretNumberString","latestNotes","fretNumber","convertFretNumberToNote","noteWithTwoChars","some","note","prevReadHadTwoDigitNumber","every","forEach","fretNumberString","parseInt","keyOffset","toLowerCase","Background","NoPrintBox","InputTextArea","textarea","OutputTextBox","OutputText","pre","App","useState","inputText","setInputText","outputText","setOutputText","signature","setSignature","useEffect","alphaTab","outArray","split","currentBlock","currentBlockLength","convertToAlphaTab","textChunks","currentChunk","width","onInput","e","target","value","alignItems","flexDirection","fontSize","ml","onChange","chunk","isArray","Fragment","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2c930b43.chunk.js","sourcesContent":["import styled from \"styled-components\";\nimport {\n    background,\n    BackgroundProps,\n    border, BorderProps,\n    flexbox, FlexboxProps,\n    layout,\n    LayoutProps,\n    shadow, ShadowProps,\n    space,\n    SpaceProps, typography, TypographyProps\n} from 'styled-system'\n\nexport interface BoxProps extends SpaceProps, LayoutProps, BackgroundProps, BorderProps, ShadowProps, TypographyProps {\n}\n\nexport const Box = styled.div<BoxProps>`\n  display: block;\n  ${space};\n  ${layout};\n  ${background};\n  ${border};\n  ${shadow};\n  ${typography}\n`\n\nexport interface FlexProps extends SpaceProps, LayoutProps, BackgroundProps, BorderProps, ShadowProps, FlexboxProps, TypographyProps {\n}\n\nexport const Flex = styled.div<FlexProps>`\n  display: flex;\n  ${flexbox};\n  ${space};\n  ${layout};\n  ${background};\n  ${border};\n  ${typography}\n  ${shadow};\n`;","\nexport const chromaticScaleSharps = [\"C\", \"C#\", \"D\" , \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\nexport const chromaticScaleFlats  = [\"C\", \"Db\", \"D\" , \"Eb\", \"E\", \"F\", \"Gb\", \"G\", \"Ab\", \"A\", \"Bb\", \"B\"];\nexport const chromaticScaleFlatsUpperCase  = chromaticScaleFlats.map(key => key.toUpperCase());\n\nconst chromaticNoteNames = Array.from(new Set([...chromaticScaleSharps, ...chromaticScaleFlats]));\n//export const tabLineBeginPattern = new RegExp(`^(${chromaticNoteNames.join(\"|\")}) ?\\\\|`, \"i\");\nexport const tabLinePattern = new RegExp(`^((${chromaticNoteNames.join(\"|\")}) ?\\\\|.+\\\\|)`, \"i\");","import {chromaticScaleFlatsUpperCase, chromaticScaleSharps, tabLinePattern} from \"./Scales\";\n\nconst SEPARATOR = '-';\n\n/**\n * All lines of the input array must be of the same length\n * Every line must match the tabLinePattern RegExp defined in Scales.ts\n * @param inputLines\n * @param blockLength\n * @param chromaticNoteName\n */\nexport function processTabBlock(inputLines: string[], blockLength: number, chromaticNoteName: string[]) {\n    const keyOffsets = inputLines.map(line => {\n        let keyName = line.match(tabLinePattern)![2].toUpperCase().trim();\n        if (chromaticScaleFlatsUpperCase.indexOf(keyName) >= 0) {\n            return chromaticScaleFlatsUpperCase.indexOf(keyName);\n        } else if (chromaticScaleSharps.indexOf(keyName) >= 0) {\n            return chromaticScaleSharps.indexOf(keyName);\n        } else {\n            throw new Error(\"could not find key for \" + keyName);\n        }\n    });\n\n    let output: string[] = inputLines.map(_ => \"\");\n\n    let prevRead: (string | null)[] | null = null;\n    for (let i = 0; i < blockLength; i++) {\n        let latestRead: (string | null)[] | null = [];\n        for (let index = 0; index < inputLines.length; index++) {\n            const line = inputLines[index];\n            if (prevRead && prevRead[index] && prevRead[index]!.length > 1) {\n                //the last time we read from this line there was a two digit number\n                //ignore this line for this iteration\n                latestRead.push(null);\n                continue;\n            }\n            const match = line.slice(i).match(/^\\d+/);\n            if (match) {\n                latestRead.push(parseFretNumberString(match[0]));\n            } else {\n                latestRead.push(null);\n            }\n        }\n\n        let latestNotes = latestRead.map((fretNumber, index) =>\n            fretNumber ? convertFretNumberToNote(fretNumber, keyOffsets[index], chromaticNoteName) : null)\n\n        const noteWithTwoChars = latestNotes.some(note => note && note.length > 1)\n        const prevReadHadTwoDigitNumber = prevRead && prevRead.some(note => note && note.length > 1)\n\n        if (!latestNotes.every(note => note === null) || !prevReadHadTwoDigitNumber) {\n        for (let index = 0; index < latestNotes.length; index++) {\n            const note = latestNotes[index];\n            if (note) {\n                output[index] += note;\n                if (note.length < 2 && noteWithTwoChars) {\n                    output[index] += SEPARATOR;\n                }\n            } else {\n                if (prevRead && prevRead[index] && prevRead[index]!.length > 1) {\n                    //the last time we read from this line there was a two digit number\n                    //ignore the current character and place a seperatore\n                    output[index] += SEPARATOR;\n                } else {\n                    output[index] += inputLines[index].slice(i, i + 1);\n                }\n                if (noteWithTwoChars) {\n                    output[index] += SEPARATOR;\n                }\n            }\n        }\n    }\n        prevRead = latestRead;\n    }\n\n    //add comments and stuff written after the actual tab back to the output\n    inputLines.forEach((line, index) => {\n        if(line.length > blockLength) {\n            output[index] += line.slice(blockLength);\n        }\n    })\n    return output\n}\n\nfunction parseFretNumberString(fretNumberString: string) {\n    if (fretNumberString.length > 2 || parseInt(fretNumberString) > 24) {\n        //in this case we have multiple numbers right behind each other without separator\n        //most guitars no not have more than 24 frets\n        //only process first number\n        return fretNumberString.slice(0, 1)\n    } else {\n        return fretNumberString;\n    }\n}\n\nfunction convertFretNumberToNote(fretNumberString: string, keyOffset: number, chromaticNoteName: string[]) {\n    const fretNumber = parseInt(fretNumberString);\n    const note = chromaticNoteName[(keyOffset + fretNumber) % 12]\n    return fretNumber >= 12 ? note.toLowerCase() : note;\n}","import React, {useEffect, useState} from 'react';\nimport styled from \"styled-components\";\nimport {Box, Flex} from \"./Layout\";\nimport {convertToAlphaTab} from \"./Parser\";\nimport {chromaticScaleFlats, chromaticScaleSharps} from \"./Scales\";\n\nconst Background = styled(Box)`\n  background-color: #282c34;\n  min-height: 100vh;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  font-size: calc(10px + 2vmin);\n  color: white;\n`;\n\nconst NoPrintBox = styled(Box)`\n  @media print {\n    display: none !important;\n  }\n`;\n\nconst InputTextArea = styled.textarea`\n  width: 100%;\n  height: 30vh;\n  color: black;\n  font-family: monospace;\n  font-size: 13px;\n  white-space: pre;\n  overflow-wrap: normal;\n  overflow-x: scroll;\n`;\n\nconst OutputTextBox = styled(Box)`\n  background-color: white;\n  width: 100%;\n  color: black;\n  font-family: monospace;\n  font-size: 13px;\n  padding: 3px;\n  overflow: auto;\n  @media print {\n    div {\n      break-inside: avoid;\n      page-break-inside:avoid;\n    }\n  }\n`;\n\nconst OutputText = styled.pre`\n  padding: 0;\n  margin: 0;\n`;\n\nconst demoInput = \"This is a utility for converting regular tab to AlphaTab, a format suggested by StudyBass.\\n\" +\n    \"See https://www.studybass.com/lessons/reading-music/alpha-tab/ for more information.\\n\" +\n    \"Just paste you tab right in here :)\\n\" +\n    \"\\n\" +\n    \"Formatting: Every line which should be interpreted as tablature should start with the root note of the string, \\n\" +\n    \"then a pipe (|), then the actual tablature and at the end another pipe.\\n\" +\n    \"\\n\" +\n    \"Demo:\\n\" +\n    \"G|---------------------------------------------|\\n\" +\n    \"D|------------------5----------------------17--|\\n\" +\n    \"A|--------2----5--------------14----17---------|\\n\" +\n    \"E|---3-------------------15--------------------|\\n\" +\n    \"\\n\" +\n    \"Demo in Drop D:\\n\" +\n    \"F|---------------------------------------------|\\n\" +\n    \"C|------------------5----------------------17--|\\n\" +\n    \"G|--------2----5--------------14----17---------|\\n\" +\n    \"D|---3-------------------15--------------------|\";\n\nfunction App() {\n    const [inputText, setInputText] = useState<string>(demoInput);\n    const [outputText, setOutputText] = useState<(string | string[])[]>([]);\n    const [signature, setSignature] = useState(\"flats\");\n\n    useEffect(() => {\n        setInputText(inputText);\n        const alphaTab = convertToAlphaTab(inputText,\n            signature === \"flats\" ? chromaticScaleFlats : chromaticScaleSharps);\n\n        //group lines with are non empty together for better printability (no page breaks in tab)\n        const textChunks: (string | string[])[] = [];\n        let currentChunk = [];\n        for (let i = 0; i < alphaTab.length; i++) {\n            if (alphaTab[i].length > 0) {\n                currentChunk.push(alphaTab[i]);\n            } else {\n                if (currentChunk.length > 0) {\n                    textChunks.push(currentChunk);\n                    currentChunk = [];\n                }\n                textChunks.push(alphaTab[i]);\n            }\n        }\n        if (currentChunk.length > 0) {\n            textChunks.push(currentChunk);\n        }\n        setOutputText(textChunks);\n    }, [inputText, signature])\n\n    return (\n        <Background>\n            <h4>Alpha Tab Converter</h4>\n            <Box width=\"80%\">\n                <NoPrintBox>\n                    <p>Input</p>\n                    <InputTextArea\n                        onInput={e => setInputText((e.target as HTMLTextAreaElement).value || \"\")}\n                        value={inputText}\n                    />\n                </NoPrintBox>\n                <Box>\n                    <NoPrintBox>\n                        <Flex alignItems=\"center\">\n                            <p>Output</p>\n                            <Flex flexDirection=\"column\" fontSize={20} ml=\"30px\">\n                                <span>Key Signature Sign</span>\n                                <select value={signature} onChange={e => setSignature(e.target.value)}>\n                                    <option value=\"flats\">Flats (b)</option>\n                                    <option value=\"sharps\">Sharps (#)</option>\n                                </select>\n                            </Flex>\n                        </Flex>\n                    </NoPrintBox>\n                    <OutputTextBox>\n                        {outputText.map((chunk, index) => {\n                            if (Array.isArray(chunk)) {\n                                return (<Box><OutputText key={index}>\n                                    {chunk.join(\"\\n\")}\n                                </OutputText></Box>);\n                            } else {\n                                return (<React.Fragment key={index}>\n                                    {chunk}<br/>\n                                </React.Fragment>);\n                            }\n                        })}\n                    </OutputTextBox>\n                </Box>\n            </Box>\n        </Background>\n    );\n}\n\nexport default App;\n","import {tabLinePattern} from \"./Scales\";\nimport {processTabBlock} from \"./TabProcessor\";\n\nexport function convertToAlphaTab(inputText: string, chromaticNoteName: string[]) {\n    let outArray: string[] = [];\n    const inputLines = inputText.split('\\n').map(line => line.trim());\n\n    //find text lines which describe 'tab' and group them together\n    let currentBlock: string[] = [];\n    let currentBlockLength = 0;\n    for (let i = 0; i < inputLines.length; i++) {\n        const match = inputLines[i].match(tabLinePattern);\n        if (match) {\n            if (currentBlock.length) {\n                if (match[0].length === currentBlockLength) {\n                    //append a line to the current block\n                    currentBlock.push(inputLines[i]);\n                } else {\n                    //the line does not match the length of the current block.\n                    //process the current block and create a new one\n                    outArray.push(...processTabBlock(currentBlock, currentBlockLength, chromaticNoteName));\n                    currentBlock= [inputLines[i]];\n                    currentBlockLength = match[0].length;\n                }\n            } else {\n                currentBlock= [inputLines[i]];\n                currentBlockLength = match[0].length;\n            }\n        } else {\n            if(currentBlock.length) {\n                //the current line does not match the regexp for tab lines but there is an active block\n                //process the block and then append the text line\n                outArray.push(...processTabBlock(currentBlock, currentBlockLength, chromaticNoteName));\n                currentBlock = [];\n                currentBlockLength = 0;\n            }\n            outArray.push(inputLines[i])\n        }\n    }\n\n    //if there is and active block after loop finish add it to the output\n    if(currentBlock.length) {\n        outArray.push(...processTabBlock(currentBlock, currentBlockLength, chromaticNoteName));\n    }\n    return outArray;\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}